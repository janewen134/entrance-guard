
关于本教程的一些说明

人脸识别应用所涉及的功能模块：
1.摄像头调用
2.脸部图像识别和处理
3.活体检测
4.多线程的应用
5.定时器的调用
6.邮件发送

知识点大纲
1.人脸识别的基本原理——计算机怎么知道照片中有没有人的脸部？哪里有脸部 ？
2.常用人脸识别库的安装和应用
3.多线程定时方法调用
4.第三方邮件发送组件yagmail的基本使用
5.活体检测算法原理

人脸识别的基本原理
机器学习简单地说是根据一堆已知的大/海量数据，利用计算机去进行演算，
最终得到一个合适的计算公式(也叫机器学习模型）来拟合这些数据的过程，
就叫机器学习。
phthon 中最常用的人脸识别库是基于C++开发的dlib库。
dlib是怎样识别人脸的呢?
在人脸上标识68个基本特征点
1—16：右耳至左耳，经过人的下颌。
17—21：右眉
22—26：左眉
27—30：鼻梁
31—35：右鼻孔至左鼻孔
36—41：右眼轮廓
42—47：左眼轮廓
48—60：嘴唇外轮廓
61—67：嘴唇内轮廓

人脸识别的基本过程：
人脸的68个基本特征点位置以及顺序在图像上是否存在，是否完整。
人脸的detect，这一步主要是定位人脸在图像中的位置，利用目标检测算法输出人脸位置矩形框，这一步需要进行训练。
人脸shape predictor，这一步就要找出眼睛眉毛鼻子嘴巴具体的点位。
人脸对齐alignment，这一步主要是通过投影几何变换出一张标准的脸，减少处理误差。
人脸识别，这一步就是在对齐的人脸图像上提取128维的特征向量，根据特征向量间的距离来进行判断识别。

dlib已经对这些过程进行了封装，我们不需要进行这些复杂的计算，只需要调用dlib的函数就可以了。
dlib库是依赖于C++和系统底层的库，需要独立安装。
1. 用pip install 命令进行安装：
安装命令：pip install -i https://pypi.douban.com/simple dlib
2.如果上面的方法安装失败，就用whl文件安装：
到 https://pypi.org/project/dlib/#files 网址上下载

dlib库是一个偏底层的库，一般不会直接用dlib库来开发。
face_recognition库是基于dlib的二次封装。号称世界上最简捷的库。
face_recognition库是基于欧美成年人脸训练的，训练数据集是 Labeled Faces in the Wild.
是美国麻省理工大学阿姆斯特分校训练的。
在网上搜集了1万3千多张人脸进行训练。
人脸识别效果的好坏即受训练影响，比如是用哪些人脸数据训练，训练集中图片的数量，也受待识别样本的效果影响。
face_recognition 库安装前一定要装好dlib库。
windows系统上的安装命令:
pip install -i https://pypi.douban.com/simple face_recognition
安装好后，主要使用的方法有：
load_image_file() : 加载图像，返回一个numpy数组，记录了图片上的所有像素的特征向量
face_location() ： 定位图片中所有人脸的像素位置
    返回值是一个列表，列表的每一行就是一张人脸信息，包括[top, right, bottom, left],可以认为每一张脸就是一个元组
face_landmarks() : 识别人脸68个关键特征点
    参数是待检测对象，返回值是一个列表，列表中的元素是包含人脸特征点的字典，列表长度就是图像中的人脸数
    面部特征包括以下几个部分：nose_bridge(鼻梁)  right_eyebrow(右眼眉) left_eyebrow(左眼眉) right_eye(右眼) left_eye(左眼)
                         chine(下巴) nose_tip(鼻下部) top_lip(上唇)  bottom_lip(下唇)
    这是一张人脸的face_landmarks()的返回值：
    [{
        'chin': [(33, 181), (34, 210), (39, 239), (46, 268), (57, 294), (73, 320), (92, 343), (114, 360), (139, 365), (164, 362), (187, 348), (206, 327), (223, 302), (235, 276), (242, 247), (246, 217), (248, 187)],
        'left_eyebrow': [(54, 168), (68, 156), (88, 153), (108, 157), (126, 164)], '
        right_eyebrow': [(150, 165), (170, 157), (191, 153), (212, 158), (227, 170)],
        'nose_bridge': [(139, 185), (139, 209), (140, 233), (140, 257)],
        'nose_tip': [(117, 267), (128, 271), (140, 275), (151, 271), (162, 267)],
        'left_eye': [(75, 185), (86, 179), (100, 179), (109, 189), (98, 190), (85, 190)],
        'right_eye': [(169, 190), (180, 181), (193, 181), (204, 187), (194, 191), (181, 192)],
        'top_lip': [(98, 302), (113, 297), (128, 294), (139, 298), (151, 294), (167, 298), (181, 303), (175, 304), (151, 306), (139, 308), (128, 306), (104, 303)],
        'bottom_lip': [(181, 303), (167, 317), (152, 324), (139, 325), (127, 323), (112, 316), (98, 302), (104, 303), (127, 306), (139, 308), (151, 306), (175, 304)]
    }]
    这些特征点分别连结就会勾勒出人脸的大体轮廓
face_encodings() : 获取图片中所有面部编码信息
    返回值是一个编码列表，参数是要识别的图像，后续访问要加上索引或遍历。每张人脸是一个128维数组
    编码信息是人像对比的重要参数。
    面部编码信息主要是用于人脸比较，与compare_face()进行人脸识别
compare_faces() : 由面部编码信息进行面部识别匹配
    主要用于匹配两个面部特征编码。利用这两个特征向量的内积来衡量相似度，两者会因表情、光线等原因而产生差异，因此可以用阈值来限定两者是否相同。/0.39/
    参数：
        1 面部编码列表（很多张脸）
        2 单个面部编码（一张脸)
        3 返回值是一个布尔值的列表，相同为True，不同为False 顺序与第一个参数中的面部编码顺序一致
        4 参数中的 tolerance值，默认是0.6， 实际经验值 tolerance=0.39 会比较准
        5 tolerance 值越小匹配越严格。所以该值设置不能太高也不能太低


